local Part1 = script.Parent.Part1
local Part2 = script.Parent.Part2

local ON = false

local NewTarget = nil
local NewStart = nil

local Folder = game.Workspace["NewPoints2.0"]
--local Folder = game.Workspace.NewParts

--local Road = {}
--local SecondOldParts = {}

--local OldParts = {}

--local OldPart = nil

local NearParts = {}

--ÖNEMLİ EĞER BİR SIKINTI VARSA 33. SATIRA BAK DİSTANCE SIKINTILI OLABİLİR
--BİRDE YUKARDAKİ FOLDERLARA DİKKAT

--wait(2)

local closest1 = nil
local closest2 = nil


print("Hey")

function FindTheClosest(CurrentPart)
	
	local WillBeCheckParts = {}
	
	
	local WillBeCheckPart1 = Instance.new("Part")
	WillBeCheckPart1.Position = CurrentPart.Position + Vector3.new(2,0,0)
	WillBeCheckPart1.Anchored = true
	WillBeCheckPart1.Parent = Folder
	WillBeCheckPart1.Size = Vector3.new(1,1,1)
	table.insert(WillBeCheckParts,1,WillBeCheckPart1)
	local WillBeCheckPart2 = Instance.new("Part")
	WillBeCheckPart2.Position = CurrentPart.Position + Vector3.new(-2,0,0)
	WillBeCheckPart2.Anchored = true
	WillBeCheckPart2.Parent = Folder
	WillBeCheckPart2.Size = Vector3.new(1,1,1)
	table.insert(WillBeCheckParts,1,WillBeCheckPart2)
	local WillBeCheckPart3 = Instance.new("Part")
	WillBeCheckPart3.Position = CurrentPart.Position + Vector3.new(0,0,2)
	WillBeCheckPart3.Anchored = true
	WillBeCheckPart3.Parent = Folder
	WillBeCheckPart3.Size = Vector3.new(1,1,1)
	table.insert(WillBeCheckParts,1,WillBeCheckPart3)
	local WillBeCheckPart4 = Instance.new("Part")
	WillBeCheckPart4.Position = CurrentPart.Position + Vector3.new(0,0,-2)
	WillBeCheckPart4.Anchored = true
	WillBeCheckPart4.Parent = Folder
	WillBeCheckPart4.Size = Vector3.new(1,1,1)
	table.insert(WillBeCheckParts,1,WillBeCheckPart4)
	local WillBeCheckPart5 = Instance.new("Part")
	WillBeCheckPart5.Position = CurrentPart.Position + Vector3.new(2,0,2)
	WillBeCheckPart5.Anchored = true
	WillBeCheckPart5.Parent = Folder
	WillBeCheckPart5.Size = Vector3.new(1,1,1)
	table.insert(WillBeCheckParts,1,WillBeCheckPart5)
	local WillBeCheckPart6 = Instance.new("Part")
	WillBeCheckPart6.Position = CurrentPart.Position + Vector3.new(2,0,-2)
	WillBeCheckPart6.Anchored = true
	WillBeCheckPart6.Parent = Folder
	WillBeCheckPart6.Size = Vector3.new(1,1,1)
	table.insert(WillBeCheckParts,1,WillBeCheckPart6)
	local WillBeCheckPart7 = Instance.new("Part")
	WillBeCheckPart7.Position = CurrentPart.Position + Vector3.new(-2,0,2)
	WillBeCheckPart7.Anchored = true
	WillBeCheckPart7.Parent = Folder
	WillBeCheckPart7.Size = Vector3.new(1,1,1)
	table.insert(WillBeCheckParts,1,WillBeCheckPart7)
	local WillBeCheckPart8 = Instance.new("Part")
	WillBeCheckPart8.Position = CurrentPart.Position + Vector3.new(-2,0,-2)
	WillBeCheckPart8.Anchored = true
	WillBeCheckPart8.Parent = Folder
	WillBeCheckPart8.Size = Vector3.new(1,1,1)
	table.insert(WillBeCheckParts,1,WillBeCheckPart8)
	
	
	for i , v in pairs(WillBeCheckParts) do

		for k , Z in pairs(game.Workspace.Parts:GetChildren()) do

			local X1,X2,Z1,Z2 = ((Z.Position.X-Z.Size.X/2)-2),((Z.Position.X+Z.Size.X/2)+2),((Z.Position.Z-Z.Size.Z/2)-2),((Z.Position.Z+Z.Size.Z/2)+2)
			if Z.Orientation == Vector3.new(0,90,0) or Z.Orientation == Vector3.new(0,-90,0) then
				X1,X2,Z1,Z2 = ((Z.Position.X-Z.Size.Z/2)-2),((Z.Position.X+Z.Size.Z/2)+2),((Z.Position.Z-Z.Size.X/2)-2),((Z.Position.Z+Z.Size.X/2)+2)
			end

			if v.Position.X > X1 and v.Position.X < X2 and v.Position.Z > Z1 and v.Position.Z < Z2 then
				
				v:Destroy()
				table.remove(WillBeCheckParts,i)
				v:Destroy()

			end


		end

	end
	
	for i , v in pairs(Folder:GetChildren()) do
		for k , t in pairs(WillBeCheckParts) do
			if t.Position == v.Position and v ~= t then
				
				t:Destroy()
				table.remove(WillBeCheckParts,k)
				t:Destroy()
				
			end
		end
	end
	
	local ClosestPart = nil
	
	wait(0.1)
	
	for i , v in pairs(WillBeCheckParts) do
		if v == CurrentPart or v.BrickColor == "Electric blue" or v.Name == "RoadPart" then
		else
			local NewDistance = (CurrentPart.Position-v.Position).Magnitude
			if NewDistance < 4 then
				--	table.insert(NearParts,1,v)
				if ClosestPart == nil then
					ClosestPart = v
				else
					print(ClosestPart.Position)
					local CurrentDistance = (closest2.Position-ClosestPart.Position).Magnitude
					local NewDistance = (closest2.Position-v.Position).Magnitude
					if NewDistance < CurrentDistance then
						ClosestPart = v
					--	print(WillBeCheckParts)
					end
				end
			end
		end
	end

	
	if ClosestPart == CurrentPart then
		
	end
	
	
	if (ClosestPart.Position-closest2.Position).Magnitude < 4 then
		print("its the end")
		
		wait(0.1)
	
	else
		
		ClosestPart.BrickColor = BrickColor.new("Electric blue")
		ClosestPart.Material = "Neon"
		ClosestPart.Name = "RoadPart"	
		
		for i , v in pairs(WillBeCheckParts) do
			if v.Name == "RoadPart" then
				print("wow")
			--	table.remove(WillBeCheckParts,i)
			else
				
				v:Destroy()

			end
		end
		
		table.clear(WillBeCheckParts)
			
		for i , v in pairs(Folder:GetChildren()) do
			if v.Name == "Part" then
				v:Destroy()
			end
		end
		
	--	wait(0.01)

		FindTheClosest(ClosestPart)
	end
	
end

function FindThePoints()
	
	local MainWhiteList = {}
	
	for i , v in pairs(game.Workspace.Parts:GetChildren()) do
		if v:IsA("Part") then
			table.insert(MainWhiteList,1,v)
		end
	end
	
	local SpecialRayParts = {}
	
	closest1 = Instance.new("Part")
	closest2 = Instance.new("Part")
	
	closest1.Position = Vector3.new(Part1.Position.X,2,Part1.Position.Z)
	closest2.Position = Vector3.new(Part2.Position.X,2,Part2.Position.Z)
	
	closest1.Size = Vector3.new(1,1,1)
	closest2.Size = Vector3.new(1,1,1)
	
	closest1.Anchored = true
	closest2.Anchored = true
	
	closest1.Parent = Folder
	closest2.Parent = Folder

	closest1.BrickColor = BrickColor.new("Lime green")
	closest2.BrickColor = BrickColor.new("Persimmon")

	closest1.Name = "StartPart"
	closest2.Name = "EndPart"
	
	table.insert(SpecialRayParts,1,closest2)
	table.insert(SpecialRayParts,1,Part2)
	table.insert(SpecialRayParts,1,Part1)
	
	for _,parts in pairs(SpecialRayParts) do
		--parts ı newray in sağa koy
	end	
	
	
	local distance = (closest2.Position - closest1.Position).magnitude
	local NewCFrame = CFrame.new(closest2.Position,closest1.Position)
	local rayDirection = NewCFrame.LookVector 

	local NewRay = Ray.new(closest2.Position, rayDirection * distance)
	local FoundedPart = workspace:FindPartOnRay(NewRay,Part1 or closest2 or Part2) --BUraya Model olcacağı için GetDescendants girilcek
	
	if FoundedPart == closest1 then
		FindTheClosest(closest1)
	else
		
		local AroundParts = {}
		local NewCheckerParts = {}
		local TargetFoundParts = {}
		local Ways = {}
		local IsTargetFound = false
	--	local TargetFoun
		
		for i,v in pairs(game.Workspace.Parts:GetChildren()) do
			
			if v.Orientation == Vector3.new(0,0,0) or v.Orientation == Vector3.new(0,180,0) then
				local AroundPartdistance1 = (closest2.Position - v.Position).magnitude
				local NewAroundPartCFrame1 = CFrame.new(closest2.Position,v.Position)
				local AroundPartRayDirection1 = NewAroundPartCFrame1.LookVector 
				local NewAroundPartRay1 = Ray.new(closest2.Position, AroundPartRayDirection1 * AroundPartdistance1)
				local AroundFoundedPart1 = workspace:FindPartOnRay(NewAroundPartRay1,Part1 or closest2 or Part2)
				local AroundPartdistance2 = (closest2.Position - Vector3.new((v.Position.X-v.Size.X/2)+0.1,v.Position.Y,(v.Position.Z-v.Size.Z/2)+0.1)).magnitude
				local NewAroundPartCFrame2 = CFrame.new(closest2.Position,Vector3.new((v.Position.X-v.Size.X/2)+0.1,v.Position.Y,(v.Position.Z-v.Size.Z/2)+0.1))
				local AroundPartRayDirection2 = NewAroundPartCFrame2.LookVector 
				local NewAroundPartRay2 = Ray.new(closest2.Position, AroundPartRayDirection2 * AroundPartdistance2)
				local AroundFoundedPart2 = workspace:FindPartOnRay(NewAroundPartRay2,Part1 or closest2 or Part2)
				local AroundPartdistance3 = (closest2.Position - Vector3.new((v.Position.X-v.Size.X/2)+0.1,v.Position.Y,(v.Position.Z+v.Size.Z/2)-0.1)).magnitude
				local NewAroundPartCFrame3 = CFrame.new(closest2.Position,Vector3.new((v.Position.X-v.Size.X/2)+0.1,v.Position.Y,(v.Position.Z+v.Size.Z/2)-0.1))
				local AroundPartRayDirection3 = NewAroundPartCFrame3.LookVector 
				local NewAroundPartRay3 = Ray.new(closest2.Position, AroundPartRayDirection3 * AroundPartdistance3)
				local AroundFoundedPart3 = workspace:FindPartOnRay(NewAroundPartRay3,Part1 or closest2 or Part2)
				local AroundPartdistance4 = (closest2.Position - Vector3.new((v.Position.X+v.Size.X/2)-0.1,v.Position.Y,(v.Position.Z-v.Size.Z/2)+0.1)).magnitude
				local NewAroundPartCFrame4 = CFrame.new(closest2.Position,Vector3.new((v.Position.X+v.Size.X/2)-0.1,v.Position.Y,(v.Position.Z-v.Size.Z/2)+0.1))
				local AroundPartRayDirection4 = NewAroundPartCFrame4.LookVector 
				local NewAroundPartRay4 = Ray.new(closest2.Position, AroundPartRayDirection4 * AroundPartdistance4)
				local AroundFoundedPart4 = workspace:FindPartOnRay(NewAroundPartRay4,Part1 or closest2 or Part2)
				local AroundPartdistance5 = (closest2.Position - Vector3.new((v.Position.X+v.Size.X/2)-0.1,v.Position.Y,(v.Position.Z+v.Size.Z/2)-0.1)).magnitude
				local NewAroundPartCFrame5 = CFrame.new(closest2.Position,Vector3.new((v.Position.X+v.Size.X/2)-0.1,v.Position.Y,(v.Position.Z+v.Size.Z/2)-0.1))
				local AroundPartRayDirection5 = NewAroundPartCFrame5.LookVector 
				local NewAroundPartRay5 = Ray.new(closest2.Position, AroundPartRayDirection5 * AroundPartdistance5)
				local AroundFoundedPart5 = workspace:FindPartOnRay(NewAroundPartRay5,Part1 or closest2 or Part2)
				if AroundFoundedPart1 == v or AroundFoundedPart2 == v or AroundFoundedPart3 == v or AroundFoundedPart4 == v or AroundFoundedPart5 == v then
					table.insert(AroundParts,1,v)
				end
			elseif v.Orientation == Vector3.new(0,90,0) or v.Orientation == Vector3.new(0,-90,0) then
				local AroundPartdistance1 = (closest2.Position - v.Position).magnitude
				local NewAroundPartCFrame1 = CFrame.new(closest2.Position,v.Position)
				local AroundPartRayDirection1 = NewAroundPartCFrame1.LookVector 
				local NewAroundPartRay1 = Ray.new(closest2.Position, AroundPartRayDirection1 * AroundPartdistance1)
				local AroundFoundedPart1 = workspace:FindPartOnRay(NewAroundPartRay1,Part1 or closest2 or Part2)
				local AroundPartdistance2 = (closest2.Position - Vector3.new((v.Position.X-v.Size.Z/2)+0.1,v.Position.Y,(v.Position.Z-v.Size.X/2)+0.1)).magnitude
				local NewAroundPartCFrame2 = CFrame.new(closest2.Position,Vector3.new((v.Position.X-v.Size.Z/2)+0.1,v.Position.Y,(v.Position.Z-v.Size.X/2)+0.1))
				local AroundPartRayDirection2 = NewAroundPartCFrame2.LookVector 
				local NewAroundPartRay2 = Ray.new(closest2.Position, AroundPartRayDirection2 * AroundPartdistance2)
				local AroundFoundedPart2 = workspace:FindPartOnRay(NewAroundPartRay2,Part1 or closest2 or Part2)
				local AroundPartdistance3 = (closest2.Position - Vector3.new((v.Position.X-v.Size.Z/2)+0.1,v.Position.Y,(v.Position.Z+v.Size.X/2)-0.1)).magnitude
				local NewAroundPartCFrame3 = CFrame.new(closest2.Position,Vector3.new((v.Position.X-v.Size.Z/2)+0.1,v.Position.Y,(v.Position.Z+v.Size.X/2)-0.1))
				local AroundPartRayDirection3 = NewAroundPartCFrame3.LookVector 
				local NewAroundPartRay3 = Ray.new(closest2.Position, AroundPartRayDirection3 * AroundPartdistance3)
				local AroundFoundedPart3 = workspace:FindPartOnRay(NewAroundPartRay3,Part1 or closest2 or Part2)
				local AroundPartdistance4 = (closest2.Position - Vector3.new((v.Position.X+v.Size.Z/2)-0.1,v.Position.Y,(v.Position.Z-v.Size.X/2)+0.1)).magnitude
				local NewAroundPartCFrame4 = CFrame.new(closest2.Position,Vector3.new((v.Position.X+v.Size.Z/2)-0.1,v.Position.Y,(v.Position.Z-v.Size.X/2)+0.1))
				local AroundPartRayDirection4 = NewAroundPartCFrame4.LookVector 
				local NewAroundPartRay4 = Ray.new(closest2.Position, AroundPartRayDirection4 * AroundPartdistance4)
				local AroundFoundedPart4 = workspace:FindPartOnRay(NewAroundPartRay4,Part1 or closest2 or Part2)
				local AroundPartdistance5 = (closest2.Position - Vector3.new((v.Position.X+v.Size.Z/2)-0.1,v.Position.Y,(v.Position.Z+v.Size.X/2)-0.1)).magnitude
				local NewAroundPartCFrame5 = CFrame.new(closest2.Position,Vector3.new((v.Position.X+v.Size.Z/2)-0.1,v.Position.Y,(v.Position.Z+v.Size.X/2)-0.1))
				local AroundPartRayDirection5 = NewAroundPartCFrame5.LookVector 
				local NewAroundPartRay5 = Ray.new(closest2.Position, AroundPartRayDirection5 * AroundPartdistance5)
				local AroundFoundedPart5 = workspace:FindPartOnRay(NewAroundPartRay5,Part1 or closest2 or Part2)
				if AroundFoundedPart1 == v or AroundFoundedPart2 == v or AroundFoundedPart3 == v or AroundFoundedPart4 == v or AroundFoundedPart5 == v then
					table.insert(AroundParts,1,v)
				end
			end
			
			
			
			--local IsThisTheSamePart = false
			
			--for k , t in pairs(AroundParts) do
			--	if t == AroundFoundedPart then
			--		IsThisTheSamePart = true
			--	end
			--end
			
			--local CheckPartAmaOnemli = Instance.new("Part")
			--CheckPartAmaOnemli.Parent = game.Workspace
			--CheckPartAmaOnemli.CFrame = NewAroundPartCFrame
			--CheckPartAmaOnemli.CFrame = CheckPartAmaOnemli.CFrame + (CheckPartAmaOnemli.CFrame.LookVector*AroundPartdistance/2)
			--CheckPartAmaOnemli.Size = Vector3.new(0.5,0.5,AroundPartdistance)
			--CheckPartAmaOnemli.Anchored = true
			
			--if IsThisTheSamePart == false then
			--	table.insert(AroundParts,1,AroundFoundedPart)
			--end
			
		end
		
		for i , v in pairs(AroundParts) do
			if v.Orientation == Vector3.new(0,0,0) or v.Orientation == Vector3.new(0,180,0) then


				local NewPart = Instance.new("Part")
				NewPart.Material = "Neon"
				NewPart.BrickColor = BrickColor.new("Deep blue")
				NewPart.Parent = v
				NewPart.Size = Vector3.new(3,3,3)
				NewPart.Anchored = true
				NewPart.Position = Vector3.new((v.Position.X-v.Size.X/2)-2,2,(v.Position.Z+v.Size.Z/2)+2)

				local NewPart = Instance.new("Part")
				NewPart.Material = "Neon"
				NewPart.BrickColor = BrickColor.new("Deep blue")
				NewPart.Parent = v
				NewPart.Size = Vector3.new(3,3,3)
				NewPart.Anchored = true
				NewPart.Position = Vector3.new((v.Position.X-v.Size.X/2)-2,2,(v.Position.Z-v.Size.Z/2)-2)

				local NewPart = Instance.new("Part")
				NewPart.Material = "Neon"
				NewPart.BrickColor = BrickColor.new("Deep blue")
				NewPart.Parent = v
				NewPart.Size = Vector3.new(3,3,3)
				NewPart.Anchored = true
				NewPart.Position = Vector3.new((v.Position.X+v.Size.X/2)+2,2,(v.Position.Z+v.Size.Z/2)+2)

				local NewPart = Instance.new("Part")
				NewPart.Material = "Neon"
				NewPart.BrickColor = BrickColor.new("Deep blue")
				NewPart.Parent = v
				NewPart.Size = Vector3.new(3,3,3)
				NewPart.Anchored = true
				NewPart.Position = Vector3.new((v.Position.X+v.Size.X/2)+2,2,(v.Position.Z-v.Size.Z/2)-2)


			elseif v.Orientation == Vector3.new(0,90,0) or v.Orientation == Vector3.new(0,-90,0) then

				--	v.BrickColor = BrickColor.new("Persimmon")

				local NewPart = Instance.new("Part")
				NewPart.Material = "Neon"
				NewPart.BrickColor = BrickColor.new("Deep blue")
				NewPart.Parent = v
				NewPart.Size = Vector3.new(3,3,3)
				NewPart.Anchored = true
				NewPart.Position = Vector3.new((v.Position.X-v.Size.Z/2)-2,2,(v.Position.Z+v.Size.X/2)+2)

				local NewPart = Instance.new("Part")
				NewPart.Material = "Neon"
				NewPart.BrickColor = BrickColor.new("Deep blue")
				NewPart.Parent = v
				NewPart.Size = Vector3.new(3,3,3)
				NewPart.Anchored = true
				NewPart.Position = Vector3.new((v.Position.X-v.Size.Z/2)-2,2,(v.Position.Z-v.Size.X/2)-2)

				local NewPart = Instance.new("Part")
				NewPart.Material = "Neon"
				NewPart.BrickColor = BrickColor.new("Deep blue")
				NewPart.Parent = v
				NewPart.Size = Vector3.new(3,3,3)
				NewPart.Anchored = true
				NewPart.Position = Vector3.new((v.Position.X+v.Size.Z/2)+2,2,(v.Position.Z+v.Size.X/2)+2)

				local NewPart = Instance.new("Part")
				NewPart.Material = "Neon"
				NewPart.BrickColor = BrickColor.new("Deep blue")
				NewPart.Parent = v
				NewPart.Size = Vector3.new(3,3,3)
				NewPart.Anchored = true
				NewPart.Position = Vector3.new((v.Position.X+v.Size.Z/2)+2,2,(v.Position.Z-v.Size.X/2)-2)

			end
		end
		
		for l,p in pairs(AroundParts) do
			
			for i , v in pairs(p:GetChildren()) do

				for k , Z in pairs(game.Workspace.Parts:GetChildren()) do
					--	if 	Z:IsA("Part") and not Z.Parent.Name == "NewPoints2.0" then

					local X1,X2,Z1,Z2 = ((Z.Position.X-Z.Size.X/2)-1.7),((Z.Position.X+Z.Size.X/2)+1.7),((Z.Position.Z-Z.Size.Z/2)-1.7),((Z.Position.Z+Z.Size.Z/2)+1.7)
					if Z.Orientation == Vector3.new(0,90,0) or Z.Orientation == Vector3.new(0,-90,0) then
						X1,X2,Z1,Z2 = ((Z.Position.X-Z.Size.Z/2)-1.7),((Z.Position.X+Z.Size.Z/2)+1.7),((Z.Position.Z-Z.Size.X/2)-1.7),((Z.Position.Z+Z.Size.X/2)+1.7)
					end
					--	local X2 = (v.Position.X+v.Size.X)
					--	local Z1 = (v.Position.Z-v.Size.Z)
					--	local Z2 = (v.Position.Z+v.Size.Z)

					if v.Position.X > X1 and v.Position.X < X2 and v.Position.Z > Z1 and v.Position.Z < Z2 then
						--	if  then
						--	Sorun = true
						v:Destroy()
						--	end	
					end

					--	end
				end

			end
			
		end
		
		for l,p in pairs(AroundParts) do
			
			for i , v in pairs(p:GetChildren()) do
				table.insert(NewCheckerParts,1,v)
			end
			
		end
		
		for i , v in pairs(NewCheckerParts) do
			
			local NewCheckerWhiteList = {closest1}
			for p,o in pairs(MainWhiteList) do
				table.insert(NewCheckerWhiteList,1,o)
			end
			
			local NewCheckerDistance = (v.Position - closest1.Position).magnitude
			local NewCheckerCFrame = CFrame.new(v.Position,closest1.Position)
			local NewCheckerRayDirection = NewCheckerCFrame.LookVector 

			local NewNewCheckerRay = Ray.new(v.Position, NewCheckerRayDirection * NewCheckerDistance)
			local FoundedNewCheckerPart = workspace:FindPartOnRayWithWhitelist(NewNewCheckerRay,NewCheckerWhiteList) 
			
			if FoundedNewCheckerPart == closest1 then
				table.insert(TargetFoundParts,1,v)
				v.BrickColor = BrickColor.new("Neon orange")
				IsTargetFound = true
			end	
		end
		
		if IsTargetFound == true then
			
			local ClosestWay = nil
			
			for i , v in pairs(TargetFoundParts) do
				
				local TargetFoundWhiteList = {closest2}
				for p,o in pairs(MainWhiteList) do
					table.insert(TargetFoundWhiteList,1,o)
				end
				
				local TargetFoundDistance = (v.Position - closest2.Position).magnitude
				local TargetFoundCFrame = CFrame.new(v.Position,closest2.Position)
				local TargetFoundRayDirection = TargetFoundCFrame.LookVector 

				local TargetFoundRay = Ray.new(v.Position, TargetFoundRayDirection * TargetFoundDistance)
				local TargetFoundedPart = workspace:FindPartOnRayWithWhitelist(TargetFoundRay,TargetFoundWhiteList) --BUraya Model olcacağı için GetDescendants girilcek
		
				
				if TargetFoundedPart == closest2 then
					local CalculateDistance = (closest1.Position-v.Position).magnitude + (v.Position-closest2.Position).magnitude
					local Road ={}
					table.insert(Road,1,closest2) 
					table.insert(Road,1,v)
					local Way = {["Distance"] = CalculateDistance; ["Road"] = Road }
					table.insert(Ways,1,Way)
				else
					for k,z in pairs(v.Parent:GetChildren()) do
						if z ~= v then
							
							local SecondStageTargetFoundDistance = (z.Position - closest2.Position).magnitude
							local SecondStageTargetFoundCFrame = CFrame.new(z.Position,closest2.Position)
							local SecondStageTargetFoundRayDirection = SecondStageTargetFoundCFrame.LookVector 

							local SecondStageTargetFoundRay = Ray.new(z.Position, SecondStageTargetFoundRayDirection * SecondStageTargetFoundDistance)
							local SecondStageTargetFoundedPart = workspace:FindPartOnRayWithWhitelist(SecondStageTargetFoundRay,TargetFoundWhiteList)
							
							if SecondStageTargetFoundedPart == closest2 then
								local CalculateDistance = (closest1.Position-v.Position).magnitude + (v.Position-z.Position).Magnitude + (z.Position-closest2.Position).magnitude
								local Road ={}
								table.insert(Road,1,closest2) 
								table.insert(Road,1,z)
								table.insert(Road,1,v)
								local Way = {["Distance"] = CalculateDistance; ["Road"] = Road }
								table.insert(Ways,1,Way)
							end
							
						end
					end
				end
				
			end
			
			for i , v in pairs(Ways) do
				if ClosestWay == nil then
					ClosestWay = v
				else
					if v.Distance < ClosestWay.Distance then
						ClosestWay = v
					end
				end
			end
			
			for i , v in pairs(ClosestWay.Road) do
				v.Material = "Neon"
				v.BrickColor = BrickColor.new("Lime green")
			end
			
		else
			--2.Aşama ve Döngü
		end
		
	end

end


while wait(0.001) do
	if ON == false then
		ON = true
		FindThePoints()
	end
end
